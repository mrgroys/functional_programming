# <h1>Лабораторная работа 1</h1>
Тема: Динамическое программирование\
Выполнила: Клещевич Юлия Алексеевна\
Группа: ИС-1
## Краткая теория
1. Динамическое программирование (DP) — это метод решения сложных задач путём разбиения их на более простые подзадачи.\
Ключевые идеи:
- Разбиение на подзадачи — большая задача делится на меньшие
- Мемоизация результатов — решения подзадач сохраняются для повторного использования
- Оптимальная субструктура — оптимальное решение задачи состоит из оптимальных решений подзадач.
2. Big O — это математическая нотация для описания асимптотического поведения функций. В программировании используется для анализа сложности алгоритмов:
- O(1) — постоянная сложность (доступ к элементу массива)
- O(log n) — логарифмическая (бинарный поиск)
- O(n) — линейная (поиск в неотсортированном массиве)
- O(n²) — квадратичная (пузырьковая сортировка)
- O(2ⁿ) — экспоненциальная (некоторые рекурсивные алгоритмы).\
\
Big O описывает наихудший случай производительности.
3. Мемоизация — это техника оптимизации, при которой результаты дорогостоящих вызовов функций сохраняются и возвращаются при повторных вызовах с теми же параметрами.\
  Преимущество: Снижает временную сложность с O(2ⁿ) до O(n) для чисел Фибоначчи.
## Решение задач
1.	**Climbing Stairs**\
Нужно понять сколько существует способов подняться на n ступенек, если можно шагать на 1 или 2 ступеньки за раз. Для этого вычисляем числа последовательности, начиная с тех случаев, где каждое следующее число = сумме двух предыдущих. Такие последовательности называются последовательностями Фибоначчи. Количество способов подняться на n ступенек = сумме способов подняться на (n-1) и (n-2) ступенек, потому что последний шаг может быть либо на 1 ступеньку, либо на 2 ступеньки.\
```
class Solution:
    def climbStairs(self, n: int) -> int:
        if n <= 2:
            return n
        
        prev1 = 1
        prev2 = 2
        
        for i in range(3, n + 1):
            current = prev1 + prev2
            prev1 = prev2
            prev2 = current
        
        return prev2
```
![Image alt](https://github.com/mrgroys/functional_programming/blob/main/1_Climbing_stairs.png)\
2.	**Jumping Game II**\
Разбивается путь на сегменты. Каждый сегмент - это максимальное расстояние, которое можно пройти за один прыжок. Когда заканчивается текущий сегмент, делается следующий прыжок в самую дальнюю точку из всех доступных в этом сегменте.
```
class Solution:
    def jump(self, nums: List[int]) -> int:
        n = len(nums)
        jumps = 0
        max_reach = 0
        current_max = 0
        
        for i in range(n - 1):
            max_reach = max(max_reach, i + nums[i])
            
            if i == current_max:
                jumps += 1
                current_max = max_reach
        
        return jumps
```
![Image alt](https://github.com/mrgroys/functional_programming/blob/main/2_Jump_game_II.png)\
3. **Pascal’s Triangle 2**\
Нужно получить конкретную строку треугольника Паскаля без построения всего треугольника. Каждое число в строке (кроме крайних единиц) вычисляется как сумма двух чисел из предыдущей строки. Создается массив из единиц, для каждой позиции обновляется значение как сумму текущего и предыдущего элемента, далее двигаемся справа налево - это позволяет использовать старые значения до их обновления.
```
class Solution:
    def getRow(self, rowIndex: int) -> List[int]:
        row = [1] * (rowIndex + 1)
        
        for i in range(1, rowIndex + 1):
            for j in range(i - 1, 0, -1):
                row[j] = row[j] + row[j - 1]
        
        return row
```
![Image alt](https://github.com/mrgroys/functional_programming/blob/main/3-Pascals_triangle_II.png)\
4.	**Best time to buy and sell stock**\
Нужно найти максимальную прибыль от покупки и продажи акций (купить до продажи). Сначала запоминаем цену первого дня как минимальную, далее для каждого следующего дня считаем прибыл если продать сегодня (цена сегодня - минимальная цена), обновляем максимальную прибыль, обновляем минимальную цену если нашли дешевле.
```
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        min_price = prices[0]
        max_profit = 0
        
        for price in prices[1:]:
            if price < min_price:
                min_price = price
            elif price - min_price > max_profit:
                max_profit = price - min_price
        
        return max_profit
```
![Image alt](https://github.com/mrgroys/functional_programming/blob/main/4_Best_time_to_buy_and_sell_stock.png)\
5.	**Best time to buy and sell stock II**\
Нужно максимизировать прибыль при множественных покупках и продажах акций. Собираем всю восходящую прибыль - покупаем вчера, продаем сегодня, если цена выросла. Проходим по всем дням начиная со второго, если цена сегодня выше цены вчера - добавляем разницу к прибыли, это эквивалентно покупке вчера и продаже сегодня.
```
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        profit = 0
        
        for i in range(1, len(prices)):
            if prices[i] > prices[i - 1]:
                profit += prices[i] - prices[i - 1]
        
        return profit
```
![Image alt](https://github.com/mrgroys/functional_programming/blob/main/5_Best_time_to_buy_and_sell_stock_II.png)
